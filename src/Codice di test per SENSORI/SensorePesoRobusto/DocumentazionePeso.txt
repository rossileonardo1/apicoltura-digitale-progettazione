# Analisi Dettagliata del Codice - Sistema Sensore di Peso

Questo Ã¨ un firmware Arduino/ESP32 per un **sistema di pesatura intelligente** con gestione completa degli errori, calibrazione, e modalitÃ  deep sleep per risparmio energetico.

---

## ğŸ“‹ STRUTTURA GENERALE

### 1. **CONFIGURAZIONI (righe 4-24)**

```cpp
// Parametri di test
static const float TEST_peso_min_kg = 0.0f;        // Peso minimo accettabile
static const float TEST_peso_max_kg = 40.0f;       // Peso massimo accettabile
static const uint64_t TEST_sleep_us = 20ULL * 1000000ULL; // Deep sleep:  20 secondi
```

**Configurazioni ADC:**
- `STABILITA_SOGLIA = 50`: Oscillazione massima accettabile tra i campioni
- `NUM_CAMPIONI_STABILITA = 10`: Numero di letture per verificare stabilitÃ 
- `TIMEOUT_ACQUISIZIONE_MS = 5000`: Tempo massimo per una lettura ADC
- `NUM_CAMPIONI_MEDIA = 5`: Campioni per calcolare la media mobile

**Configurazioni Calibrazione:**
- Range offset: da -100 a +100 (compensazione zero)
- Range coefficiente: da 0.001 a 100 (fattore di conversione ADC â†’ kg)

---

## ğŸ”´ GESTIONE ERRORI (righe 26-42)

Il sistema implementa **15 codici di errore specifici**:

### Errori Hardware (01-05)
- **ERR_PS_2_01**: ADC non pronto (problema hardware)
- **ERR_PS_2_02**: Timeout acquisizione (comunicazione fallita)
- **ERR_PS_2_03**: Saturazione ADC (valore ai limiti fisici)
- **ERR_PS_2_04**: Valore instabile (troppa oscillazione)
- **ERR_PS_2_05**:  Outlier rilevato (picco anomalo)

### Errori Calibrazione (06-08)
- **ERR_PS_2_06**: Calibrazione non presente
- **ERR_PS_2_07**: Calibrazione non valida
- **ERR_PS_2_08**: Errore conversione ADC â†’ kg

### Errori Validazione (09-11)
- **ERR_PS_2_09**: Peso fuori range (< 0 o > 40 kg)
- **ERR_PS_2_10**: Peso negativo oltre tolleranza
- **ERR_PS_2_11**: Misura instabile dopo wake-up

### Errori Comunicazione (12-15)
- **ERR_PS_2_12**: Timestamp mancante
- **ERR_PS_2_13**: Timestamp non valido
- **ERR_PS_2_14**: Invio fallito
- **ERR_PS_2_15**: Duplicazione misura

---

## ğŸ—‚ï¸ STRUTTURE DATI (righe 44-74)

### **TaraturaData**
```cpp
struct TaraturaData {
  float offset;                  // Compensazione zero
  float coefficiente;            // Fattore di conversione
  bool valida;                   // Stato calibrazione
  uint32_t timestamp_taratura;   // Quando Ã¨ stata fatta
};
```

### **MisuraWeight**
```cpp
struct MisuraWeight {
  float valore_kg;               // Peso misurato
  uint64_t timestamp_ms;         // Timestamp in millisecondi
  uint32_t timestamp_unix;       // Timestamp Unix epoch
  bool valida;                   // Misura valida o no
  ErrorCode ultimo_errore;       // Ultimo errore riscontrato
  uint16_t tentativo_invio;      // Numero di tentativi di invio
  uint32_t hash_misura;          // Hash per rilevare duplicati
};
```

### **StatusSensore**
Contiene lo stato globale del sistema:
- Stato ADC e sensore (online/offline)
- Timestamp ultimo wake-up
- Flag prima lettura dopo risveglio
- Dati di calibrazione
- Ultima misura acquisita

---

## ğŸ”§ FUNZIONI PRINCIPALI

### **1. Verifica Hardware (righe 111-182)**

#### `verificaReadinessADC()`
```cpp
// Attende che l'ADC sia pronto
// In produzione leggerebbe un pin READY
// Qui simula un'attesa di 100ms
```

#### `verificaSaturazioneADC()`
```cpp
// ADC a 24 bit:  range 0 - 16. 777.215
// Se il valore Ã¨ vicino ai limiti â†’ saturazione
// Margine di tolleranza: 100 conteggi
```

#### `verificaStabilita()`
```cpp
// Prende 10 campioni
// Calcola oscillazione = max - min
// Se oscillazione > 50 â†’ ERRORE
```

#### `rileva_outlier()`
```cpp
// Calcola media e deviazione standard
// Se un campione Ã¨ oltre 3Ïƒ â†’ outlier
```

---

### **2. Calibrazione (righe 184-232)**

#### `verificaTaratura()`
Verifica che: 
- La calibrazione esista (`valida = true`)
- L'offset sia nel range [-100, +100]
- Il coefficiente sia nel range [0.001, 100]

#### `impostaTaratura(offset, coefficiente)`
```cpp
// Imposta i parametri di calibrazione
// Valida i valori prima di salvare
// Aggiorna timestamp calibrazione
```

#### `taraturaDifferenzaPeso()`
```cpp
// Procedura di calibrazione: 
// 1. Posizionare a zero
// 2. Azzeramento via seriale
// 3. Peso noto per calibrazione
// Per test: offset=0, coeff=0.001
```

---

### **3. Conversione ADC â†’ Peso (righe 269-292)**

#### `conversioneInKg()`
```cpp
// Formula: kg = (adc_raw - offset) Ã— coefficiente
// 
// Esempio con ADC = 8. 388.608 (metÃ  scala 24bit)
// offset = 0
// coefficiente = 0.001
// 
// kg = (8.388.608 - 0) Ã— 0.001 = 8388.608 kg
// 
// Controlla NaN e infinito
```

---

### **4. Validazione Peso (righe 294-313)**

#### `verificaRangePeso()`
```cpp
// Verifica:  0 kg â‰¤ peso â‰¤ 40 kg
// Se fuori range â†’ ALERT + ERRORE
```

#### `verificaPesoNegativo()`
```cpp
// Tolleranza: -0.5 kg
// Se peso < -0.5 kg â†’ ERRORE
// (permette piccole fluttuazioni del zero)
```

---

### **5. Timestamp (righe 315-346)**

#### `generaTimestamp()`
```cpp
// Genera due timestamp:
// 1. millis() - da accensione
// 2. Unix epoch - timestamp reale
// 
// Validazione:  anno tra 2024-2050
// In produzione: usa RTC o NTP
```

---

### **6. Anti-Duplicazione (righe 348-379)**

#### `calcolaHashMisura()`
```cpp
// Combina valore peso + timestamp
// Hash = XOR(bits_float) XOR timestamp
// Rileva misure duplicate
```

#### `verificaDuplicazione()`
```cpp
// Confronta hash con ultima misura
// Se uguali â†’ duplicazione
```

---

### **7. Acquisizione Misura (righe 395-527)**

#### `acquisisciMisura()` - **FUNZIONE CENTRALE**

Esegue un **processo in 13 step**:

```cpp
1. âœ… Verifica stabilitÃ  post wake-up (aspetta 2 secondi)
2. âœ… Verifica ADC pronto
3. âœ… Verifica timeout acquisizione
4. ğŸ“Š Leggi ADC (simulato:  8.388.608)
5. âœ… Verifica saturazione
6. âœ… Verifica stabilitÃ  (10 campioni)
7. âœ… Verifica outlier (5 campioni)
8. ğŸ”„ Conversione ADC â†’ kg
9. âœ… Verifica peso negativo
10. âœ… Verifica range (0-40 kg)
11. ğŸ• Genera timestamp
12. #ï¸âƒ£ Calcola hash e verifica duplicazione
13. âœ… Misura valida â†’ salva
```

**Se qualsiasi step fallisce:**
- Imposta `ultimo_errore`
- Ritorna codice errore
- Log dettagliato

---

### **8. Salvataggio e Comunicazione (righe 529-586)**

#### `salvaMemoriaLocale()`
```cpp
// Buffer locale:  10 misure
// Se connessione assente â†’ salva qui
// Previene perdita dati offline
```

#### `sincronizzaCloudDb()`
```cpp
// Quando connessione disponibile: 
// - Invia tutte le misure bufferate
// - Svuota buffer
// Simulato nel codice
```

#### `invioAlertPesoFuoriRange()`
```cpp
// Invia notifica urgente se peso fuori range
// Gestisce retry (ERR_PS_2_14)
```

---

### **9. Ciclo Principale (righe 588-624)**

#### `cicloSensorePeso()`

```cpp
========== CICLO SENSORE DI PESO ==========

1. ğŸ”§ Taratura del sensore
   â””â”€ impostaTaratura(0. 0f, 0.001f)

2. ğŸ“Š Acquisizione misura
   â””â”€ acquisisciMisura(&misura)
   â””â”€ Se errore â†’ log + deep sleep

3. ğŸ’¾ Aggiorna ultima misura
   â””â”€ g_status.ultima_misura = misura

4. âš ï¸ Verifica soglie
   â””â”€ Se < min o > max â†’ invio alert

5. ğŸ’½ Salvataggio memoria locale
   â””â”€ salvaMemoriaLocale(misura)

6. â˜ï¸ Sincronizzazione cloud
   â””â”€ sincronizzaCloudDb(true)

7. ğŸ’¤ Deep Sleep (20 secondi)
   â””â”€ ritornoInDeepSleep()
```

---

### **10. Deep Sleep (righe 626-637)**

#### `ritornoInDeepSleep()`
```cpp
// 1. Aggiorna timestamp ultimo wake-up
// 2. Setta flag "prima lettura"
// 3. Configura timer:  20 secondi
// 4. ESP32 entra in deep sleep
// 
// Consumo: ~10 ÂµA (vs ~240 mA attivo)
// Batteria 2000mAh â†’ ~22 anni! 
```

---

## ğŸ”„ FLUSSO DI ESECUZIONE

```
BOOT ESP32
    â†“
setup()
    â†“
cicloSensorePeso()
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1.  TARATURA        â”‚
â”‚  offset = 0         â”‚
â”‚  coeff = 0.001      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ï¿½ï¿½ï¿½â”€â”€â”€â”
â”‚  2. ACQUISIZIONE    â”‚
â”‚  â€¢ Verifica ADC     â”‚
â”‚  â€¢ Leggi 10 campioniâ”‚
â”‚  â€¢ Calcola media    â”‚
â”‚  â€¢ Converti in kg   â”‚
â”‚  â€¢ Valida range     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. VALIDAZIONE     â”‚
â”‚  â€¢ Range 0-40 kg?    â”‚
â”‚  â€¢ Peso negativo?   â”‚
â”‚  â€¢ Duplicato?       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. ALERT (se fuori)â”‚
â”‚  â€¢ < 0 kg â†’ ALERT   â”‚
â”‚  â€¢ > 40 kg â†’ ALERT  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. SALVATAGGIO     â”‚
â”‚  â€¢ Buffer locale    â”‚
â”‚  â€¢ Max 10 misure    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. SYNC CLOUD      â”‚
â”‚  â€¢ Invia misure     â”‚
â”‚  â€¢ Svuota buffer    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  7. DEEP SLEEP      â”‚
â”‚  ğŸ’¤ 20 secondi      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
WAKE UP â†’ ripeti
```

---

## ğŸ¯ CARATTERISTICHE AVANZATE

### **1. Robustezza**
- âœ… 15 tipi di errore gestiti
- âœ… Validazione multi-livello
- âœ… Anti-duplicazione
- âœ… Outlier detection (3Ïƒ)

### **2. Risparmio Energetico**
- âœ… Deep sleep tra misure
- âœ… Wake-up temporizzato
- âœ… Stabilizzazione post-wake

### **3. AffidabilitÃ  Dati**
- âœ… Buffer locale (offline-first)
- âœ… Sincronizzazione automatica
- âœ… Hash per integritÃ 
- âœ… Timestamp doppio

### **4. Calibrazione**
- âœ… Offset + coefficiente
- âœ… Validazione parametri
- âœ… Timestamp calibrazione
- âœ… Procedura guidata

---

## ğŸ“Š ESEMPIO DI OUTPUT

```
=== SISTEMA SENSORE DI PESO - AVVIO ===

========== CICLO SENSORE DI PESO ==========
1. Taratura del sensore... 

=== PROCEDURA DI TARATURA ===
1. Posizionare il sensore a zero (senza peso)
2. Inviare comando di azzeramento via seriale
3. Posizionare peso noto e inviare valore di calibrazione
Taratura impostata con successo

2. Acquisizione misura... 
Peso OK:  8388. 608 kg

3. Verifica soglie (min/max)...
ERROR: ERR-PS-2.09 - Peso fuori range min/max
ALERT [PESO FUORI RANGE]: 8388.608 kg
ALERT:  Invio notifica peso fuori range = 8388.608 kg

4. Salvataggio memoria locale...
Misura salvata su memoria locale

5. Tentativo sincronizzazione cloud... 
INFO: Tentativo sincronizzazione dati locali con Cloud/DB... 
  - Invio misura 1:  8388.608 kg
INFO: Sincronizzazione completata

6. Configurazione Deep Sleep...
Deep Sleep 20 secondi...
```

---

## âš ï¸ NOTE IMPORTANTI

### **Valori Simulati**
```cpp
// ADC simulato a metÃ  scala
uint32_t adc_raw = 8388608; 

// Risultato:  8388.608 kg (FUORI RANGE!)
// Normale: con offset e coeff corretti â†’ 0-40 kg
```

### **In Produzione Servono:**
1. ğŸ“¡ Comunicazione SPI/I2C reale con ADC (HX711, ADS1220, etc.)
2. ğŸ• RTC o NTP per timestamp reali
3. ğŸ“¶ WiFi/LoRa/GSM per sincronizzazione cloud
4. ğŸ’¾ EEPROM/SPIFFS per persistenza calibrazione
5. ğŸ”‹ Gestione batteria e power management

---

## ğŸ“ CONCLUSIONE

Questo codice implementa un **sistema di pesatura industriale** con:
- âœ… Gestione errori completa
- âœ… Calibrazione professionale
- âœ… Efficienza energetica estrema
- âœ… AffidabilitÃ  dei dati
- âœ… ModalitÃ  offline-first

Ideale per applicazioni IoT come:
- ğŸ Bilance per arnie
- ğŸ“¦ Sistemi di inventario
- ğŸ­ Monitoraggio industriale
- ğŸŒ¾ Agricoltura di precisione